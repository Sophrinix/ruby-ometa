
ometa RubyOMetaTranslator {
  trans [:t apply('t'):ans]             -> ans
	,
  App  'super' anything+:args         -> ['_superApplyWithArgs(', args.join(','), ')'].join('')
	,
  App  :rule   anything+:args         -> ['_applyWithArgs("', rule, '",',      args.join(','), ')'].join('')
	,
  App  :rule                          -> ['_apply("', rule, '")']                                  .join('')
	,
  Act  :expr                          -> expr
	,
  Pred :expr                          -> ['_pred(', expr, ')']                                     .join('')
	,
  Or   transFn*:xs                    -> ['_or(', xs.join(','), ')']                               .join('')
	,
  And  notLast('"trans"')*:xs trans:y    -> (( xs.push('return ' + y); ['(proc{', xs.join(';'), '}).call'].join('') ))
	,
  And                                 -> '(proc{})'
	,
  Many  trans:x                       -> ['_many(proc{return ', x, '})']                     .join('')
	,
  Many1 trans:x                       -> ['_many1(proc{return ', x, '})']                    .join('')
	,
  Set   :n trans:v                    -> [n, '=', v].join('')
	,
  Not   trans:x                       -> ['_not(proc{return ', x, '})']                      .join('')
	,
  Lookahead trans:x                   -> ['_lookahead(proc{return ', x, '})']                .join('')
	,
  Form  trans:x                       -> ['_form(proc{return ', x, '})']                     .join('')
	,
  Rule  :name locals:ls trans:body    -> ["def ", name, "\n", ls, "\nreturn ", body, "\nend\n"]         .join('')
	,
  Grammar :name :sName
          trans*:rules                -> ["Class.new(", sName, ") do\n@name = ", name.inspect, "\n", rules.join("\n"), 'end']      .join('')
					,
  locals  = [anything+:vs]              -> vs.map { |v| "#{v} = " }.join + 'nil'
          | []                        -> ''
	,
  transFn = trans:x                   -> ['(proc{return ', x, '})']                               .join('')
}

